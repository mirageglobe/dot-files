# === references
# - https://devhints.io/ansible

# === basic commands

# === array

- name: set variable
  set_fact:
    fact_mylist:
      - "first variable"
      - "second variable"

# === class

# no class; see function

# === if

- name: if condition
  shell: |
      echo "test";
  when: mylist is defined and mytask is success

# === function

# block can be used as function
tasks:
  - name: Install, configure, and start Apache
    block:
      - name: task 1
        shell: |
          echo "test"
      - name: task 2
        shell: |
          echo "test 2"
    when: myvar == "enable"
    become: true
    become_user: root
    ignore_errors: yes

# === loop

# === === nested array loop

- name: Read values {{ myvalue }}
  shell: |
      echo "{{ item }} # this is value";
  loop: {{ mylist | default([], true) }}
  when: mylist is defined

# === === nested array loop

# loop example for nested dictionary
dictionary:
  topic1:
    - t1-sub1
    - t1-sub2
  topic2:
    - t2-sub1
    - t2-sub2

allowlist:
  - topic1

# loops nested dictionary with conditional to check against allowlist
- name: Read values {{ myvalue }}
  shell: |
      echo "one : {{ item.0.key }} # this is key i.e. topic1";
      echo "two : {{ item.1 }} # this is value i.e. t1-sub1";
  loop: "{{ dictionary | dict2items | subelements('value') }}"
  when: item.0.key in allowlist

# loops from main task to subtask
- include_tasks: inner.yml
  with_items:
    - "{{ dictionary | dict2items }}"
  vars:
    mkey: "{{ item.key }}"
    mvalue: "{{ item.value }}"

# double nested loop

db_sql_schema:
  - db: jldb1
    tables:
      - name: 'jldb1_table1'
        partitionkey: '/partitionKey'
      - name: 'jldb1_table2'
        partitionkey: '/partitionKey'
  - db: jldb2
    tables:
      - name: 'jldb2_table1'
        partitionkey: "/partitionKey"

- name: List db
  debug:
    msg: "databases = {{ item.db }}"
  loop: "{{ db_sql_schema }}"

- name: List tables
  debug:
    msg: "db = {{ item.0.db }} collection = {{ item.1.name }} key = {{ item.1.partitionkey }}"
  loop: "{{ db_sql_schema | subelements('tables') }}"

- name: Test
  shell: |
    echo "{{ item }}";
  loop: "{{ db_sql_schema | default({}, true) }}"

# === print

# show using echo
- name: print {{ myvalue }}
  shell: |
    echo "one: {{ myvalue }}";

# show using debug
- name: debug_set_fact
  set_fact:
    fact_foo: "{{ output_response.stdout | from_json }}"

- name: debug_main
  debug:
    var: fact_foo

# === regex

# search for "foo" in "foobar"
{{ 'foobar' | regex_search('(foo)') }}

# will return empty if it cannot find a match
{{ 'ansible' | regex_search('(foobar)') }}

# case insensitive search in multiline mode
{{ 'foo\nBAR' | regex_search("^bar", multiline=True, ignorecase=True) }}

# === switch

vars:
   myDict:
     string1: a
     string2: b
   new_ansible_var: '{{ myDict[existing_ansible_var | default("this key does not exist in the dict")] | default("") }}'

# === variable

# variable string
myvar: "value"

# variable from other results
myvar: "{{ output_response.stdout }}"

# variable via set fact
- name: set_fact_variable
  set_fact:
    fact_foo: "{{ output_response.stdout | from_json }}"

# variable via set fact with conditions
- name: set_fact_variable
  set_fact:
    fact_foo: "{{ 'this is true' if (some_result == True) else 'this is false' }}"

# === helper functions

# === === debug using fact

# set fact will show values in logs without debug
- name: debug_set_fact
  set_fact:
    fact_foo: "{{ output_response.stdout | from_json }}"

- name: debug_main
  debug:
    var: fact_foo

# === === debug message

- name: debug {{ myvalue }}
  shell: |
    echo "one: {{ myvalue }}";
    printf "{{ myvalue2 }}";
  register: output_myresponse

- name: debug show value
  shell: |
    echo "{{ output_myresponse.stdout | default([], true) | from_json | json_query('id') }}";
  register: output_myresponse_id

# === try catch

tasks:
  - name: install, configure, and start app
    block:
      - name: install base
        shell: |
          echo "test"
    rescue:
      - name: print when error
        ansible.builtin.debug:
          msg: 'I caught an error, can do stuff here to fix it, :-)'
    always:
      - name: always do this
        ansible.builtin.debug:
          msg: "this always executes"
    become: true
    ignore_errors: yes
handlers:
  - name: run me even after an error
    ansible.builtin.debug:
    msg: 'this handler runs even on error'

- name: Display message to pause and check until condition
  pause:
    seconds: 10
    prompt: |
      ======================
      Found {{ number_of_nodes | length }} on {{ example_cluster }}.
      Ensure that there is only 1 node on cluster {{ example_cluster }}

      Contact xxxx to clean up and action the above.
      ======================
  when: number_of_nodes | length > 1
